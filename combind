#!/bin/env python

import pandas as pd
import numpy as np
import click
import os
from glob import glob
from schrodinger.structure import StructureReader, StructureWriter
from utils import *

###############################################################################

# Defaults
stats_root = os.environ['COMBINDHOME']+'/stats_data/rd1_all'
mcss_version = 'mcss16'
shape_version = 'pharm_max'
ifp_version = 'rd1'

@click.group()
def main():
    pass

@main.command()
@click.argument('struct', default='')
def structprep(struct):
    """
    Prepare structures and make a docking grid.

    "struct" specifies the name of the structure for which to make a docking
    grid. (Not the full path, generally just the PDB code.) Defaults to the
    structure with alphabetically lowest name.

    The following directory structure is required:

    \b
    structures/
        raw/
            structure_name_prot.mae
            structure_name_lig.mae
            ...
        processed/
            structure_name/structure_name_out.mae
            ...
        aligned/
            structure_name/rot-structure_name_query.mae
            ...
        proteins/
            structure_name_prot.mae
            ...
        ligands/
            structure_name_lig.mae
            ...
        grids/
            structure_name/structure_name.zip
            ...

    The process can be started from any step, e.g. if you have processed
    versions of your structures, you can place these in the processed directory.

    Files ending with _lig contain only the small molecule ligand present in the
    structure, and files ending with _prot contain everything else.
    """
    from dock.struct_align import struct_align
    from dock.struct_sort import struct_sort
    from dock.struct_process import struct_process
    from dock.grid import make_grid

    assert os.path.exists('structures'), 'No structures directory.'

    if not struct:
        struct = glob('structures/raw/*_prot.mae*')
        if not struct:
            struct = glob('structures/proteins/*_prot.mae*')
        struct = sorted(struct)[0]
        struct = struct.split('/')[-1].split('_prot')[0]

    struct_process()
    struct_align(struct)
    struct_sort()
    make_grid(struct)

@main.command()
@click.argument('smiles')
@click.argument('root')
@click.option('--screen', is_flag=True)
@click.option('--processes', default=1)
def ligprep(smiles, root, screen, processes):
    """
    Prepare ligands for docking, from smiles.

    Specifically, this will run Schrodinger's ligprep and then perform
    additional processing to make the ligands readable by rdkit and to assign
    atom names.

    "smiles" should be a space delimited file with columns 'ID' and 'SMILES'.
    "root" specifies where the processed ligands will be written. 

    By default, an individual file will be made for each ligand. If screen is
    set, then only one file, containing all the ligands, will be produced.
    """
    from dock.ligprep import ligprep
    mkdir(root)
    ligands = pd.read_csv(smiles, sep=' ')

    if screen:
        _smiles = '{}/{}'.format(root, os.path.basename(smiles))
        _mae = smiles.replace('.smi', '.maegz')
        
        if not os.path.exists(_mae):
            with open(_smiles, 'w') as fp:
                for _, ligand in ligands.iterrows():
                    fp.write('{} {}\n'.format(ligand['SMILES'], ligand['ID']))
            ligprep(_smiles)
    else:
        unfinished = []
        for _, ligand in ligands.iterrows():
            _root = '{}/{}'.format(root, ligand['ID'])
            _smiles = '{}/{}/{}.smi'.format(root, ligand['ID'], ligand['ID'])
            _mae = _smiles.replace('.smi', '.maegz')
            
            if not os.path.exists(_mae):
                mkdir(_root)
                with open(_smiles, 'w') as fp:
                    fp.write('{} {}\n'.format(ligand['SMILES'], ligand['ID']))
                unfinished += [(_smiles,)]
        mp(ligprep, unfinished, processes)  

@main.command()
@click.argument('grid')
@click.argument('root')
@click.argument('ligands', nargs=-1)
@click.option('--screen', is_flag=True)
@click.option('--processes', default=1)
def dock(grid, root, ligands, screen, processes):
    """
    Dock "ligands" to "grid".

    "root" specifies where the docking results will be written.

    Setting "screen" limits the thoroughness of the pose sampling. Recommended
    for screening, but not pose prediction.

    "ligands" are paths to prepared ligand files. Multiple can be specified.
    """
    from dock.dock import dock
    ligands = [os.path.abspath(lig) for lig in ligands if 'nonames' not in lig]
    grid = os.path.abspath(grid)
    root = os.path.abspath(root)

    mkdir(root)
    unfinished = []
    for ligand in ligands:
        name = '{}-to-{}'.format(basename(ligand), basename(grid))
        _root = '{}/{}'.format(root, name)
        unfinished += [(grid, ligand, _root, name, not screen, 1)]
    mp(dock, unfinished, processes)

@main.command()
@click.argument('poseviewer')
@click.argument('native')
@click.option('--thresh', default=2.0)
def filter_native(poseviewer, native, thresh):
    """
    Filter for near-native poses.

    Writes a new version of "poseviewer" only containing the poses
    within RMSD "thresh" of the provided "native" pose.
    """
    from dock.dock import filter_native
    out = poseviewer.replace('_pv.maegz', '_native_pv.maegz')
    filter_native(native, poseviewer, out, thresh)

@main.command()
@click.argument('smiles')
@click.argument('grid')
@click.argument('root')
def check_dock(smiles, grid, root):
    """
    Check that ligprep and docking completed successfully.
    """
    from dock.dock import docking_failed
    ligands = pd.read_csv(smiles, sep=' ')

    # Check ligprep
    for _, ligand in ligands.iterrows():
        _root = '{}/ligands/{}'.format(root, ligand['ID'])
        _mae = '{}/{}.maegz'.format(_root, ligand['ID'])

        if not os.path.exists(_mae):
            print('{} not prepped '.format(ligand['ID']))

    # Check docking
    for _, ligand in ligands.iterrows():
        _name = '{}-to-{}'.format(ligand['ID'], basename(grid))
        _root = '{}/docking/{}'.format(root, _name)
        _pv = '{}/{}_pv.maegz'.format(_root, _name)
        _log = '{}/{}.log'.format(_root, _name)

        if not os.path.exists(_pv) and not docking_failed(_log):
            print('{} not docked'.format(ligand['ID']))

################################################################################

@main.command()
@click.argument('root')
@click.argument('poseviewers', nargs=-1)
@click.option('--ifp-version', default=ifp_version)
@click.option('--mcss-version', default=mcss_version)
@click.option('--shape-version', default=shape_version)
@click.option('--screen', is_flag=True)
@click.option('--max-poses', default=0)
@click.option('--no-mcss', is_flag=True)
@click.option('--no-shape', is_flag=True)
@click.option('--processes', default=1)
def featurize(root, poseviewers, ifp_version, mcss_version, shape_version,
              screen, no_mcss, no_shape, processes, max_poses):
    """
    Compute pose similarity features.

    Features are written with the following directory convention:

    \b
    root/
        gscore/
        ifp/
        ifp-pair/
        shape/
        mcss/
    """
    from features.features import Features
    if screen:
        assert len(poseviewers) == 2
        max_poses =  max_poses if max_poses is None else 1000000
    else:
        poseviewers = sorted(poseviewers)
        max_poses = max_poses if max_poses else 100

    features = Features(root, ifp_version=ifp_version, shape_version=shape_version,
                        mcss_version=mcss_version, max_poses=max_poses)
    features.compute_features(poseviewers, processes=processes,
                              mcss=not no_mcss, shape=not no_shape)

################################################################################

@main.command()
@click.argument('root')
@click.argument('out')
@click.argument('ligands', nargs=-1)
@click.option('--xtal', multiple=True)
@click.option('--features', default='shape,mcss,hbond,saltbridge,contact')
@click.option('--alpha', default=1.0)
@click.option('--gc50', default=float('inf'))
@click.option('--max_poses', default=100)
@click.option('--stats-root', default=stats_root)
@click.option('--ifp-version', default=ifp_version)
@click.option('--mcss-version', default=mcss_version)
@click.option('--shape-version', default=shape_version)
@click.option('--restart', default=500)
@click.option('--max-iterations', default=1000)
def pose_prediction(root, out, ligands, alpha, gc50, max_poses,
                    stats_root, ifp_version, mcss_version, shape_version,
                    xtal, features, restart, max_iterations):
    """
    Run ComBind pose prediction.
    """
    from score.pose_prediction import PosePrediction
    from score.statistics import read_stats
    from features.features import Features

    features = features.split(',')

    protein = Features(root, ifp_version=ifp_version, shape_version=shape_version,
                       mcss_version=mcss_version, max_poses=max_poses)
    protein.load_features(features)

    if not ligands:
        ligands = list(protein.raw['gscore'].keys())
    ligands = sorted(ligands)

    stats = read_stats(stats_root, features)
    
    ps = PosePrediction(ligands, protein.raw, stats, xtal, features,
                        max_poses, alpha, gc50)
    best_poses = ps.max_posterior(max_iterations, restart)
    probs = ps.get_poses_prob(best_poses)

    with open(out, 'w') as fp:
        fp.write('ID,POSE,PROB\n')
        for ligand in best_poses:
            fp.write('{},{},{}\n'.format(ligand.replace('_pv', ''),
                                         best_poses[ligand],
                                         probs[ligand]))

@main.command()
@click.argument('score-fname')
@click.argument('gscore-fname')
@click.option('--pose-prob-fname', default=None)
@click.option('--ifp-fname', default=None)
@click.option('--mcss-fname', default=None)
@click.option('--shape-fname', default=None)
@click.option('--stats-root', default=stats_root)
@click.option('--alpha', default=1.0)
@click.option('--features', default='shape,hbond,saltbridge,contact')
def screen(score_fname, stats_root, gscore_fname, ifp_fname, mcss_fname,
           shape_fname, alpha, features, pose_prob_fname):
    """
    Run ComBind screening.
    """
    from score.screen import screen, load_features_screen
    from score.statistics import read_stats

    if pose_prob_fname is not None:
        weights = pd.read_csv(pose_prob_fname)
        weights = weights['PROB'].to_numpy()
    else:
        weights = None

    features = features.split(',')
    stats = read_stats(stats_root, features)
    single, raw = load_features_screen(
        features, gscore_fname, ifp_fname, mcss_fname, shape_fname)

    combind_energy = screen(single, raw, stats, alpha, weights=weights)
    np.save(score_fname, combind_energy)

################################################################################

@main.command()
@click.argument('scores')
@click.argument('pv-root')
def extract_top_poses(scores, pv_root):
    """
    Write top-scoring poses to a single file.
    """
    out = scores.replace('.csv', '_pv.maegz')

    df = pd.read_csv(scores)
    prot = get_pose(pv_path(pv_root, df.loc[0, 'ID']), -1)
    sts = []
    for _, ligand in df.iterrows():
        pv = pv_path(pv_root, ligand['ID'])
        sts += [get_pose(pv, ligand['POSE'])]

    with StructureWriter(out) as writer:
        writer.append(prot)
        for st in sts:
            if st.title[0] == '_':
                st.title = st.title[1:]
            writer.append(st)

@main.command()
@click.argument('pv')
@click.argument('scores')
@click.argument('out', default=None)
def apply_scores(pv, scores, out):
    """
    Add ComBind screening scores to a poseviewer.
    """
    if out is None:
        out = pv.replace('_pv.maegz', '_combind_pv.maegz')

    scores = np.load(scores)

    with StructureReader(pv) as reader, StructureWriter(out) as writer:
        st = next(reader)
        st.property['r_i_combind_score'] = 1000.0
        writer.append(st)
        for st, score in zip(reader, scores):
            st.property['r_i_combind_score'] = score
            writer.append(st)

@main.command()
@click.argument('pv')
@click.argument('out', default=None)
def scores_to_csv(pv, out):
    """
    Write docking and ComBind scores to text.
    """
    if out is None:
        out = pv.replace('_pv.maegz', '_combind_pv.maegz')

    titles, glide, combind = [], [], []
    with StructureReader(pv) as reader:
        next(reader)
        for st in reader:
            titles += [st.title]
            glide += [st.property['r_i_docking_score']]
            combind += [st.property['r_i_combind_score']]

    df = pd.DataFrame(np.vstack([titles, glide, combind]).T,
                      columns = ['ID', 'GLIDE', 'COMBIND'])
    df.to_csv(out, index=False)

main()
